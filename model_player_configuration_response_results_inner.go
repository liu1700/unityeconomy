/*
Economy API

# Introduction   This document outlines the API specification for the Economy API.   The Economy service allows the game client to retrieve and modify a player's economy resources in the cloud. # Concepts   ## Resources   Economy currently allows interaction with the following types of resources:   - Currencies: A resource that, when defined, contains two parameters: Initial and Max. The Initial parameter determines how much of the currency a game assigns to a player upon first interacting with the Economy system. The Max parameter determines how much of the currency the player is allowed to have.   - Inventory Items: A resource that doesn't have any set parameters; its intended use is to indicate the ownership or acquisition of an item in-game, for example, Sword and Shield.     A game client can add, remove or update the associated data of an instance of a configured inventory item from the player's inventory.   - Virtual Purchases: A transactional resource to implement a shop or trade feature. Allows the player to buy items/currencies using the previously defined currencies or inventory items.     A game client can redeem a virtual purchase and the player's account updates with the rewards if the costs criteria are met.   - Real Money Purchases: A transactional resource with the intended use to facilitate a shop or trade feature. Allows the player to buy any amount of items/currencies through an in-app purchase. Only uses the previously defined currencies or inventory items.     A game client can redeem a real money purchase and the player's account updates with the rewards.    The above resources also have an optional Custom Data parameter that can be populated with JSON data from the dashboard to allow clients to read bespoke data.   ## Writelock   The WriteLock is an integer that is automatically incremented serverside whenever a request that changes the stored value of a player's account or inventory.   The purpose of the WriteLock is to help prevent requests from the same or other game clients happening out-of-sync.   This parameter is optional, but when supplied with a request, the service does a comparison with the stored WriteLock on the server, and returns an error on mismatch.   ## Rate Limits   The API has rate limiting in place. Requests are limited on a per-player basis up to 150 requests per minute.   The API responds with a `429` HTTP status code if the requests exceed the rate limit.   Responses with a `429` status code include a `Retry-After` header to be used in conjunction with a client's retry logic, the value is the number of seconds until a request for the given player is accepted. 

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package unityeconomy

import (
	"encoding/json"
	"fmt"
)

// PlayerConfigurationResponseResultsInner - struct for PlayerConfigurationResponseResultsInner
type PlayerConfigurationResponseResultsInner struct {
	CurrencyResource *CurrencyResource
	InventoryItemResource *InventoryItemResource
	RealMoneyPurchaseResource *RealMoneyPurchaseResource
	VirtualPurchaseResource *VirtualPurchaseResource
}

// CurrencyResourceAsPlayerConfigurationResponseResultsInner is a convenience function that returns CurrencyResource wrapped in PlayerConfigurationResponseResultsInner
func CurrencyResourceAsPlayerConfigurationResponseResultsInner(v *CurrencyResource) PlayerConfigurationResponseResultsInner {
	return PlayerConfigurationResponseResultsInner{
		CurrencyResource: v,
	}
}

// InventoryItemResourceAsPlayerConfigurationResponseResultsInner is a convenience function that returns InventoryItemResource wrapped in PlayerConfigurationResponseResultsInner
func InventoryItemResourceAsPlayerConfigurationResponseResultsInner(v *InventoryItemResource) PlayerConfigurationResponseResultsInner {
	return PlayerConfigurationResponseResultsInner{
		InventoryItemResource: v,
	}
}

// RealMoneyPurchaseResourceAsPlayerConfigurationResponseResultsInner is a convenience function that returns RealMoneyPurchaseResource wrapped in PlayerConfigurationResponseResultsInner
func RealMoneyPurchaseResourceAsPlayerConfigurationResponseResultsInner(v *RealMoneyPurchaseResource) PlayerConfigurationResponseResultsInner {
	return PlayerConfigurationResponseResultsInner{
		RealMoneyPurchaseResource: v,
	}
}

// VirtualPurchaseResourceAsPlayerConfigurationResponseResultsInner is a convenience function that returns VirtualPurchaseResource wrapped in PlayerConfigurationResponseResultsInner
func VirtualPurchaseResourceAsPlayerConfigurationResponseResultsInner(v *VirtualPurchaseResource) PlayerConfigurationResponseResultsInner {
	return PlayerConfigurationResponseResultsInner{
		VirtualPurchaseResource: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *PlayerConfigurationResponseResultsInner) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into CurrencyResource
	err = newStrictDecoder(data).Decode(&dst.CurrencyResource)
	if err == nil {
		jsonCurrencyResource, _ := json.Marshal(dst.CurrencyResource)
		if string(jsonCurrencyResource) == "{}" { // empty struct
			dst.CurrencyResource = nil
		} else {
			match++
		}
	} else {
		dst.CurrencyResource = nil
	}

	// try to unmarshal data into InventoryItemResource
	err = newStrictDecoder(data).Decode(&dst.InventoryItemResource)
	if err == nil {
		jsonInventoryItemResource, _ := json.Marshal(dst.InventoryItemResource)
		if string(jsonInventoryItemResource) == "{}" { // empty struct
			dst.InventoryItemResource = nil
		} else {
			match++
		}
	} else {
		dst.InventoryItemResource = nil
	}

	// try to unmarshal data into RealMoneyPurchaseResource
	err = newStrictDecoder(data).Decode(&dst.RealMoneyPurchaseResource)
	if err == nil {
		jsonRealMoneyPurchaseResource, _ := json.Marshal(dst.RealMoneyPurchaseResource)
		if string(jsonRealMoneyPurchaseResource) == "{}" { // empty struct
			dst.RealMoneyPurchaseResource = nil
		} else {
			match++
		}
	} else {
		dst.RealMoneyPurchaseResource = nil
	}

	// try to unmarshal data into VirtualPurchaseResource
	err = newStrictDecoder(data).Decode(&dst.VirtualPurchaseResource)
	if err == nil {
		jsonVirtualPurchaseResource, _ := json.Marshal(dst.VirtualPurchaseResource)
		if string(jsonVirtualPurchaseResource) == "{}" { // empty struct
			dst.VirtualPurchaseResource = nil
		} else {
			match++
		}
	} else {
		dst.VirtualPurchaseResource = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.CurrencyResource = nil
		dst.InventoryItemResource = nil
		dst.RealMoneyPurchaseResource = nil
		dst.VirtualPurchaseResource = nil

		return fmt.Errorf("data matches more than one schema in oneOf(PlayerConfigurationResponseResultsInner)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(PlayerConfigurationResponseResultsInner)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src PlayerConfigurationResponseResultsInner) MarshalJSON() ([]byte, error) {
	if src.CurrencyResource != nil {
		return json.Marshal(&src.CurrencyResource)
	}

	if src.InventoryItemResource != nil {
		return json.Marshal(&src.InventoryItemResource)
	}

	if src.RealMoneyPurchaseResource != nil {
		return json.Marshal(&src.RealMoneyPurchaseResource)
	}

	if src.VirtualPurchaseResource != nil {
		return json.Marshal(&src.VirtualPurchaseResource)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *PlayerConfigurationResponseResultsInner) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.CurrencyResource != nil {
		return obj.CurrencyResource
	}

	if obj.InventoryItemResource != nil {
		return obj.InventoryItemResource
	}

	if obj.RealMoneyPurchaseResource != nil {
		return obj.RealMoneyPurchaseResource
	}

	if obj.VirtualPurchaseResource != nil {
		return obj.VirtualPurchaseResource
	}

	// all schemas are nil
	return nil
}

type NullablePlayerConfigurationResponseResultsInner struct {
	value *PlayerConfigurationResponseResultsInner
	isSet bool
}

func (v NullablePlayerConfigurationResponseResultsInner) Get() *PlayerConfigurationResponseResultsInner {
	return v.value
}

func (v *NullablePlayerConfigurationResponseResultsInner) Set(val *PlayerConfigurationResponseResultsInner) {
	v.value = val
	v.isSet = true
}

func (v NullablePlayerConfigurationResponseResultsInner) IsSet() bool {
	return v.isSet
}

func (v *NullablePlayerConfigurationResponseResultsInner) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePlayerConfigurationResponseResultsInner(val *PlayerConfigurationResponseResultsInner) *NullablePlayerConfigurationResponseResultsInner {
	return &NullablePlayerConfigurationResponseResultsInner{value: val, isSet: true}
}

func (v NullablePlayerConfigurationResponseResultsInner) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePlayerConfigurationResponseResultsInner) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


