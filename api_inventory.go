/*
Economy API

# Introduction   This document outlines the API specification for the Economy API.   The Economy service allows the game client to retrieve and modify a player's economy resources in the cloud. # Concepts   ## Resources   Economy currently allows interaction with the following types of resources:   - Currencies: A resource that, when defined, contains two parameters: Initial and Max. The Initial parameter determines how much of the currency a game assigns to a player upon first interacting with the Economy system. The Max parameter determines how much of the currency the player is allowed to have.   - Inventory Items: A resource that doesn't have any set parameters; its intended use is to indicate the ownership or acquisition of an item in-game, for example, Sword and Shield.     A game client can add, remove or update the associated data of an instance of a configured inventory item from the player's inventory.   - Virtual Purchases: A transactional resource to implement a shop or trade feature. Allows the player to buy items/currencies using the previously defined currencies or inventory items.     A game client can redeem a virtual purchase and the player's account updates with the rewards if the costs criteria are met.   - Real Money Purchases: A transactional resource with the intended use to facilitate a shop or trade feature. Allows the player to buy any amount of items/currencies through an in-app purchase. Only uses the previously defined currencies or inventory items.     A game client can redeem a real money purchase and the player's account updates with the rewards.    The above resources also have an optional Custom Data parameter that can be populated with JSON data from the dashboard to allow clients to read bespoke data.   ## Writelock   The WriteLock is an integer that is automatically incremented serverside whenever a request that changes the stored value of a player's account or inventory.   The purpose of the WriteLock is to help prevent requests from the same or other game clients happening out-of-sync.   This parameter is optional, but when supplied with a request, the service does a comparison with the stored WriteLock on the server, and returns an error on mismatch.   ## Rate Limits   The API has rate limiting in place. Requests are limited on a per-player basis up to 150 requests per minute.   The API responds with a `429` HTTP status code if the requests exceed the rate limit.   Responses with a `429` status code include a `Retry-After` header to be used in conjunction with a client's retry logic, the value is the number of seconds until a request for the given player is accepted. 

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package unityeconomy

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// InventoryAPIService InventoryAPI service
type InventoryAPIService service

type ApiAddInventoryItemRequest struct {
	ctx context.Context
	ApiService *InventoryAPIService
	projectId string
	playerId string
	addInventoryRequest *AddInventoryRequest
	configAssignmentHash *string
	unityInstallationId *string
	analyticsUserId *string
}

func (r ApiAddInventoryItemRequest) AddInventoryRequest(addInventoryRequest AddInventoryRequest) ApiAddInventoryItemRequest {
	r.addInventoryRequest = &addInventoryRequest
	return r
}

// Configuration assignment hash that should be used when processing this request.
func (r ApiAddInventoryItemRequest) ConfigAssignmentHash(configAssignmentHash string) ApiAddInventoryItemRequest {
	r.configAssignmentHash = &configAssignmentHash
	return r
}

// Unique identifier that identifies an installation on the clientâ€™s device. The same player can have different installationIds if they have the game installed on different devices. It is available to all Unity packages that integrate with the Services SDK Core package.
func (r ApiAddInventoryItemRequest) UnityInstallationId(unityInstallationId string) ApiAddInventoryItemRequest {
	r.unityInstallationId = &unityInstallationId
	return r
}

// A unique string that identifies the player and is consistent across their subsequent play sessions for analytics purposes. It is the primary user identifier and it comes from the Core package.
func (r ApiAddInventoryItemRequest) AnalyticsUserId(analyticsUserId string) ApiAddInventoryItemRequest {
	r.analyticsUserId = &analyticsUserId
	return r
}

func (r ApiAddInventoryItemRequest) Execute() (*InventoryResponse, *http.Response, error) {
	return r.ApiService.AddInventoryItemExecute(r)
}

/*
AddInventoryItem Add inventory item

Add an item to a player's inventory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project.
 @param playerId ID of the player.
 @return ApiAddInventoryItemRequest
*/
func (a *InventoryAPIService) AddInventoryItem(ctx context.Context, projectId string, playerId string) ApiAddInventoryItemRequest {
	return ApiAddInventoryItemRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		playerId: playerId,
	}
}

// Execute executes the request
//  @return InventoryResponse
func (a *InventoryAPIService) AddInventoryItemExecute(r ApiAddInventoryItemRequest) (*InventoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryAPIService.AddInventoryItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/players/{playerId}/inventory"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playerId"+"}", url.PathEscape(parameterValueToString(r.playerId, "playerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addInventoryRequest == nil {
		return localVarReturnValue, nil, reportError("addInventoryRequest is required and must be specified")
	}

	if r.configAssignmentHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configAssignmentHash", r.configAssignmentHash, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.unityInstallationId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "unity-installation-id", r.unityInstallationId, "")
	}
	if r.analyticsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "analytics-user-id", r.analyticsUserId, "")
	}
	// body params
	localVarPostBody = r.addInventoryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SetPlayerCurrencyBalance400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseConflictInventory
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteInventoryItemRequest struct {
	ctx context.Context
	ApiService *InventoryAPIService
	projectId string
	playerId string
	playersInventoryItemId string
	configAssignmentHash *string
	unityInstallationId *string
	analyticsUserId *string
	writeLock *string
	inventoryDeleteRequest *InventoryDeleteRequest
}

// Configuration assignment hash that should be used when processing this request.
func (r ApiDeleteInventoryItemRequest) ConfigAssignmentHash(configAssignmentHash string) ApiDeleteInventoryItemRequest {
	r.configAssignmentHash = &configAssignmentHash
	return r
}

// Unique identifier that identifies an installation on the clientâ€™s device. The same player can have different installationIds if they have the game installed on different devices. It is available to all Unity packages that integrate with the Services SDK Core package.
func (r ApiDeleteInventoryItemRequest) UnityInstallationId(unityInstallationId string) ApiDeleteInventoryItemRequest {
	r.unityInstallationId = &unityInstallationId
	return r
}

// A unique string that identifies the player and is consistent across their subsequent play sessions for analytics purposes. It is the primary user identifier and it comes from the Core package.
func (r ApiDeleteInventoryItemRequest) AnalyticsUserId(analyticsUserId string) ApiDeleteInventoryItemRequest {
	r.analyticsUserId = &analyticsUserId
	return r
}

// The writelock for a database entry.
func (r ApiDeleteInventoryItemRequest) WriteLock(writeLock string) ApiDeleteInventoryItemRequest {
	r.writeLock = &writeLock
	return r
}

func (r ApiDeleteInventoryItemRequest) InventoryDeleteRequest(inventoryDeleteRequest InventoryDeleteRequest) ApiDeleteInventoryItemRequest {
	r.inventoryDeleteRequest = &inventoryDeleteRequest
	return r
}

func (r ApiDeleteInventoryItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteInventoryItemExecute(r)
}

/*
DeleteInventoryItem Delete player's inventory item

Delete a player's inventory item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project.
 @param playerId ID of the player.
 @param playersInventoryItemId The `playersInventoryItemId` of the item to be updated.
 @return ApiDeleteInventoryItemRequest
*/
func (a *InventoryAPIService) DeleteInventoryItem(ctx context.Context, projectId string, playerId string, playersInventoryItemId string) ApiDeleteInventoryItemRequest {
	return ApiDeleteInventoryItemRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		playerId: playerId,
		playersInventoryItemId: playersInventoryItemId,
	}
}

// Execute executes the request
func (a *InventoryAPIService) DeleteInventoryItemExecute(r ApiDeleteInventoryItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryAPIService.DeleteInventoryItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/players/{playerId}/inventory/{playersInventoryItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playerId"+"}", url.PathEscape(parameterValueToString(r.playerId, "playerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playersInventoryItemId"+"}", url.PathEscape(parameterValueToString(r.playersInventoryItemId, "playersInventoryItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configAssignmentHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configAssignmentHash", r.configAssignmentHash, "")
	}
	if r.writeLock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "writeLock", r.writeLock, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.unityInstallationId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "unity-installation-id", r.unityInstallationId, "")
	}
	if r.analyticsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "analytics-user-id", r.analyticsUserId, "")
	}
	// body params
	localVarPostBody = r.inventoryDeleteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SetPlayerCurrencyBalance400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseConflictInventoryDelete
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPlayerInventoryRequest struct {
	ctx context.Context
	ApiService *InventoryAPIService
	projectId string
	playerId string
	configAssignmentHash *string
	unityInstallationId *string
	analyticsUserId *string
	after *string
	limit *int32
	playersInventoryItemIds *[]string
	inventoryItemIds *[]string
}

// Configuration assignment hash that should be used when processing this request.
func (r ApiGetPlayerInventoryRequest) ConfigAssignmentHash(configAssignmentHash string) ApiGetPlayerInventoryRequest {
	r.configAssignmentHash = &configAssignmentHash
	return r
}

// Unique identifier that identifies an installation on the clientâ€™s device. The same player can have different installationIds if they have the game installed on different devices. It is available to all Unity packages that integrate with the Services SDK Core package.
func (r ApiGetPlayerInventoryRequest) UnityInstallationId(unityInstallationId string) ApiGetPlayerInventoryRequest {
	r.unityInstallationId = &unityInstallationId
	return r
}

// A unique string that identifies the player and is consistent across their subsequent play sessions for analytics purposes. It is the primary user identifier and it comes from the Core package.
func (r ApiGetPlayerInventoryRequest) AnalyticsUserId(analyticsUserId string) ApiGetPlayerInventoryRequest {
	r.analyticsUserId = &analyticsUserId
	return r
}

// The &#x60;playersInventoryItemId&#x60; after which to retrieve the next page of balances.
func (r ApiGetPlayerInventoryRequest) After(after string) ApiGetPlayerInventoryRequest {
	r.after = &after
	return r
}

// Number of items to be returned. Defaults to 20.
func (r ApiGetPlayerInventoryRequest) Limit(limit int32) ApiGetPlayerInventoryRequest {
	r.limit = &limit
	return r
}

// List of &#x60;playersInventoryItemIds&#x60; in array notation, for example, &#x60;playersInventoryItemIds[]&#x3D;ID1&amp;playersInventoryItemIds[]&#x3D;ID2&#x60;.
func (r ApiGetPlayerInventoryRequest) PlayersInventoryItemIds(playersInventoryItemIds []string) ApiGetPlayerInventoryRequest {
	r.playersInventoryItemIds = &playersInventoryItemIds
	return r
}

// List of inventory item IDs in array notation, for example, &#x60;inventoryItemIds[]&#x3D;ID1&amp;inventoryItemIds[]&#x3D;ID2&#x60;.
func (r ApiGetPlayerInventoryRequest) InventoryItemIds(inventoryItemIds []string) ApiGetPlayerInventoryRequest {
	r.inventoryItemIds = &inventoryItemIds
	return r
}

func (r ApiGetPlayerInventoryRequest) Execute() (*PlayerInventoryResponse, *http.Response, error) {
	return r.ApiService.GetPlayerInventoryExecute(r)
}

/*
GetPlayerInventory List player inventory

Get a list of inventory for a player.
Results ordered by ascending `playersInventoryItemId`.
`playersIventoryItemIds` and `inventoryItemIds` filters are optional, if not given all items will be returned. If both are given an item must match both to be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project.
 @param playerId ID of the player.
 @return ApiGetPlayerInventoryRequest
*/
func (a *InventoryAPIService) GetPlayerInventory(ctx context.Context, projectId string, playerId string) ApiGetPlayerInventoryRequest {
	return ApiGetPlayerInventoryRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		playerId: playerId,
	}
}

// Execute executes the request
//  @return PlayerInventoryResponse
func (a *InventoryAPIService) GetPlayerInventoryExecute(r ApiGetPlayerInventoryRequest) (*PlayerInventoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlayerInventoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryAPIService.GetPlayerInventory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/players/{playerId}/inventory"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playerId"+"}", url.PathEscape(parameterValueToString(r.playerId, "playerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configAssignmentHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configAssignmentHash", r.configAssignmentHash, "")
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.playersInventoryItemIds != nil {
		t := *r.playersInventoryItemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "playersInventoryItemIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "playersInventoryItemIds", t, "multi")
		}
	}
	if r.inventoryItemIds != nil {
		t := *r.inventoryItemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inventoryItemIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inventoryItemIds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.unityInstallationId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "unity-installation-id", r.unityInstallationId, "")
	}
	if r.analyticsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "analytics-user-id", r.analyticsUserId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateInventoryItemRequest struct {
	ctx context.Context
	ApiService *InventoryAPIService
	projectId string
	playerId string
	playersInventoryItemId string
	inventoryRequestUpdate *InventoryRequestUpdate
	configAssignmentHash *string
	unityInstallationId *string
	analyticsUserId *string
}

func (r ApiUpdateInventoryItemRequest) InventoryRequestUpdate(inventoryRequestUpdate InventoryRequestUpdate) ApiUpdateInventoryItemRequest {
	r.inventoryRequestUpdate = &inventoryRequestUpdate
	return r
}

// Configuration assignment hash that should be used when processing this request.
func (r ApiUpdateInventoryItemRequest) ConfigAssignmentHash(configAssignmentHash string) ApiUpdateInventoryItemRequest {
	r.configAssignmentHash = &configAssignmentHash
	return r
}

// Unique identifier that identifies an installation on the clientâ€™s device. The same player can have different installationIds if they have the game installed on different devices. It is available to all Unity packages that integrate with the Services SDK Core package.
func (r ApiUpdateInventoryItemRequest) UnityInstallationId(unityInstallationId string) ApiUpdateInventoryItemRequest {
	r.unityInstallationId = &unityInstallationId
	return r
}

// A unique string that identifies the player and is consistent across their subsequent play sessions for analytics purposes. It is the primary user identifier and it comes from the Core package.
func (r ApiUpdateInventoryItemRequest) AnalyticsUserId(analyticsUserId string) ApiUpdateInventoryItemRequest {
	r.analyticsUserId = &analyticsUserId
	return r
}

func (r ApiUpdateInventoryItemRequest) Execute() (*InventoryResponse, *http.Response, error) {
	return r.ApiService.UpdateInventoryItemExecute(r)
}

/*
UpdateInventoryItem Update player's inventory item

Update a player's inventory item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId ID of the project.
 @param playerId ID of the player.
 @param playersInventoryItemId The `playersInventoryItemId` of the item to be updated.
 @return ApiUpdateInventoryItemRequest
*/
func (a *InventoryAPIService) UpdateInventoryItem(ctx context.Context, projectId string, playerId string, playersInventoryItemId string) ApiUpdateInventoryItemRequest {
	return ApiUpdateInventoryItemRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		playerId: playerId,
		playersInventoryItemId: playersInventoryItemId,
	}
}

// Execute executes the request
//  @return InventoryResponse
func (a *InventoryAPIService) UpdateInventoryItemExecute(r ApiUpdateInventoryItemRequest) (*InventoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InventoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryAPIService.UpdateInventoryItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{projectId}/players/{playerId}/inventory/{playersInventoryItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playerId"+"}", url.PathEscape(parameterValueToString(r.playerId, "playerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playersInventoryItemId"+"}", url.PathEscape(parameterValueToString(r.playersInventoryItemId, "playersInventoryItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inventoryRequestUpdate == nil {
		return localVarReturnValue, nil, reportError("inventoryRequestUpdate is required and must be specified")
	}

	if r.configAssignmentHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configAssignmentHash", r.configAssignmentHash, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.unityInstallationId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "unity-installation-id", r.unityInstallationId, "")
	}
	if r.analyticsUserId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "analytics-user-id", r.analyticsUserId, "")
	}
	// body params
	localVarPostBody = r.inventoryRequestUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SetPlayerCurrencyBalance400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseConflictInventoryUpdate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v BasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
